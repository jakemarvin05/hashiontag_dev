{>blockHeader/}

{! TODO: SOMETHING IS WRONG WITH POST.dust #imgfield "accepts" criteria !}

<script src="{p.js}/socket.io.js"></script>
<script>
var socket = io.connect();
// var socket = io.connect('/post', {
//     // Disables the automatic reconnection
//     reconnect: false
// });
var socketId = '';

socket.on('welcome', function (data) {
    socketId = data.message;
});

// Reconnects on disconnection
socket.on('disconnect', function(){
    console.log("reconnecting to server....");
    //VERIFY
    socket.connect();
});

socket.on('uploadProgress', function(data){
    var percentage = data.bytesReceived/data.bytesExpected;
    console.log(percentage);
    $('#progressBar').css('width', parseInt(percentage)*100+'%');
});
</script>

<script src="{p.js}/vvImg.js"></script>
<script>
VV.img.CSRender = {CSRender};
</script>

{>blockHeaderAfterHook/}

<section id="main">
    <div class="mainColBlock">

        {?isLoggedIn}

        <style>
        #cropPortCont {
            width: 100%;
        }
            #cropPortBg {
                max-height: 0px;
                position: relative;
                top: 20px;
                width: 280px;
                margin: auto;
            }
             #cropPortBg img {
                display: block;
                margin: auto;
                position: relative;
                opacity: 0.4;
                filter: alpha(opacity=40);
             }
            #cropPort {
                height:280px; 
                width:280px; 
                box-sizing:border-box; 
                border:2px dotted #e44447;
                margin: 20px auto;
                overflow: hidden;
            }
        img[id^=img_preview], canvas[id^=img_preview] {
            position:relative;
            left:-2px;
            top:-2px;
        }
        #img_field {
            opacity: 0;
            filter: alpha(opacity=0);
            position: absolute;
            max-height: 0px;
            max-width: 0px;
        }
        #browseCont, #scaleCont, #postCont {
            text-align:center;
        }
        #scaleSliderCont {
            width:280px;
            height: 50px;
            padding-top: 20px;
            margin:auto;
        }
            #scaleSlider {
                width: 100%;
                height: 2px;
                background-color: #ccc;
            }   
            #scaleSliderBut {
                background-color: #e74447;
                margin-top: -14px;
                margin-left: 10px;
                width: 50px;
                height: 25px;
                cursor: move;
            }


        #progressBarCont {
            height: 20px;
            width: 280px;
            background-color: #ccc;
            margin: auto;
        }
            #progressBar {
                height: 100%;
                width: 0%;
                background-color: #d91639;
                -webkit-transition: width 0.5s;
                transition: width 0.5s;
            }
        </style>

        <div id="cropPortCont">
            <div id="cropPortBg"></div>
            <div id="cropPort"></div>
        </div>
        <script>
        //set the crop port
        var windowW = $(window).width();
        if(windowW > 640) {
            VV.img.CROP_PORT = 480;
            $("#cropPort").css('height', VV.img.CROP_PORT).css('width', VV.img.CROP_PORT);
            $("#cropPortBg").css('width', VV.img.CROP_PORT);
        }
        //init dragShifting
        $(function() {
            dragShifting.init();
            //init pinch scaling
            scaleSlider.pinch.init(document.getElementById('cropPort'));
        });
        </script>
        <div id="browseCont">
            <button id="browseButton">Browse</button>
            <input id="img_field" type="file" name="img" accept="image/jpeg,image/gif,image/png" required></input>
        </div>
        <script>
        //bind button to input="file"
        $('#browseButton').click(function() {
            $('#img_field').focus().trigger('click');
        });
        </script>

        {! Bindings for these buttons are below !}
        <div id="scaleCont" style="display:none">
            <div id="scaleSliderCont">
                <div id="scaleSlider"></div>
                <div id="scaleSliderBut"></div>
                <script>
                //init scale slider button
                $(function() { scaleSlider.init($('#scaleSliderBut')) });
                </script>
            </div>
            <button id="doneScaling">Done scaling</button>
        </div>
        <div id="postCont" style="display:none">
            <textarea id="desc" name="desc" required></textarea>
            <button id="postIt">Post</button>
        </div>

        <div id="progressBarCont" style="display:none">
            <div id="progressBar"></div>
        </div>
        
    
        <!--<p>
            Progress: <input id="progress" name="progressPercent" required></input>
        </p>-->

        {:else}
        <h1>Post</h1>
        You are not logged in. To post, please log in <a href="{#p}{login}{/p}">here</a>
        {/isLoggedIn}
    </div>
    <!-- end your stream -->
</section><!-- main -->

{>blockFooter/}

<script src="{p.js}/exif.binaryjax.js"></script>
{!<script type="text/javascript" src="{p.js}/caman.full.min.js"></script>!}

<script>
/*****************
* Drag shifting *
*****************/
var dragShifting = {}
dragShifting.$target = '';
dragShifting.getTarget = function() { return dragShifting.$target = $('#img_preview'); }
dragShifting.mousedown = function(self, e) {
    //console.log("Mousedown Event");
    self.getTarget(); //set $target
    if(self.$target.length === 0) { return false; }
    if(e.button === 0 || e.type === "touchstart") {
        if(e.type==="touchstart") {
            if(e.originalEvent.touches.length === 2) {
                return false;
            }
            e.stopPropagation(); e.preventDefault();
            e=e.originalEvent.touches[0]||e.originalEvent.changedTouches[0];
        }
        var imgW = self.$target.width(),
            imgH = self.$target.height();

        self.startX = e.pageX;
        self.startY = e.pageY;    
        self.minX = VV.img.CROP_PORT - imgW;
        self.minY = VV.img.CROP_PORT - imgH;
        self.maxX = 0;
        self.maxY = 0;

        $('#cropPort').on("mousemove.ds touchmove.ds", function (e) {
            self.mousemove(self, e)
        });
    }
}
dragShifting.mousemove = function(self, e) {
    //console.log('mousemove');
    e.stopPropagation(); e.preventDefault();
    if (e.type==='touchmove') e=e.originalEvent.touches[0]||e.originalEvent.changedTouches[0];

    self.endX = e.pageX;
    self.endY = e.pageY;
    return self.shifter(self);
}
dragShifting.shifter = function (self) {
    VV.img.IMG_X += self.endX - self.startX;
    VV.img.IMG_Y += self.endY - self.startY;
    // Update image position based on Boundary
    if (VV.img.IMG_X < self.minX) {
        VV.img.IMG_X = self.minX;
    } else if (VV.img.IMG_X > self.maxX) {
        VV.img.IMG_X = self.maxX;
    }
    if (VV.img.IMG_Y < self.minY) {
        VV.img.IMG_Y = self.minY;
    } else if (VV.img.IMG_Y > self.maxY) {
        VV.img.IMG_Y = self.maxY;
    }
    // Reset starting offsets
    self.startX = self.endX; self.startY = self.endY;
    // Render image
    self.$target.css({
        'margin-top': VV.img.IMG_Y.toString() + "px",
        'margin-left': VV.img.IMG_X.toString() + "px"
    });  
    $('#cropPortBg img').css({
        'top': VV.img.IMG_Y.toString() + "px",
        'left': VV.img.IMG_X.toString() + "px"
    });  
}
dragShifting.kill = function($el) {
    $el.unbind('mousedown.ds touchstart.ds mousemove.ds touchmove.ds');
}
dragShifting.init = function() {
    var self = dragShifting;

    // Bind drag event to mousedown/touchdown at image container
    $('#cropPort').on('mousedown.ds touchstart.ds', function (e) {
        self.mousedown(self, e);
    });

    // Unbind drag event to mouseup/touchend at window
    $(window).on("mouseup touchend", function () {
        //console.log("Mouseup Event");
        $('#cropPort').unbind('mousemove.ds touchmove.ds');
    });
}

/*******************
* Slider *
*******************/

var scaleSlider = {}

scaleSlider.lengthOf = 280;
scaleSlider.stopLimits = 10; //10px on each side.
scaleSlider.buttonWidth = 0;
scaleSlider.travel = 0;
scaleSlider.currentPosit = 0;
scaleSlider.percent = function() { return scaleSlider.currentPosit / scaleSlider.travel; }
scaleSlider.startX = 0;

scaleSlider.reset = function($el) {
    scaleSlider.currentPosit = 0;
    //$el.velocity({marginLeft: scaleSlider.stopLimits + 'px'}, {duration: 300});
    $el.css('marginLeft', scaleSlider.stopLimits + 'px');
}

scaleSlider.init = function($el) {
    scaleSlider.buttonWidth = $el.width();
    scaleSlider.travel = scaleSlider.lengthOf - (2 * scaleSlider.stopLimits) - scaleSlider.buttonWidth;

    $(window).on("mouseup.sl touchend.sl", function(e) {
        console.log("mouseup event");
        $(window).unbind("mousemove.sl touchmove.sl");
    })

    $el.on("mousedown.sl touchstart.sl",function(e){
        if($('#img_preview').length === 0) { return false; }
        if (e.button === 0 || e.type === "touchstart") {
            e.stopPropagation(); e.preventDefault();
            if (e.type==="touchstart") e=e.originalEvent.touches[0]||e.originalEvent.changedTouches[0];
 
            scaleSlider.startX = e.pageX;

            $(window).on("mousemove.sl touchmove.sl", function(e){

                console.log('mousemove');
                if (e.type=="touchmove") e=e.originalEvent.touches[0]||e.originalEvent.changedTouches[0];
                endX = e.pageX;
                var moveX = endX - scaleSlider.startX;
                var currentX = scaleSlider.currentPosit;
                var transientX = currentX + moveX;
                var minX = 0;
                var maxX = scaleSlider.travel;

                if(transientX <= minX) {
                   var currentX = minX;
                } else if(transientX >= maxX) {
                   var currentX = maxX;
                } else {
                   var currentX = transientX;
                }
                //update
                scaleSlider.currentPosit = currentX;
                var margin = currentX + scaleSlider.stopLimits;
                $el.css('margin-left', margin + 'px');
                var scale = scaleSlider.percent() + 1;
                VV.img.scaler(scale, $('#img_preview'), $('#cropPortBg img'));
                // Reset starting offsets
                scaleSlider.startX = endX;
            });
        }
    });
}
scaleSlider.pinch = {}
scaleSlider.pinch.sensitivity = 0.6;
scaleSlider.pinch.init = function(el) {

    var oScale = 0;

    pinchCropPort = new Hammer(el);
    pinchCropPort.get('pinch').set({ enable: true });

    pinchCropPort.on('pinchstart', function(e) {
        oScale = e.scale;
    });

    pinchCropPort.on('pinchmove', function(e) {
        var newScale = e.scale;
        var delScale = newScale - oScale;
        delScale = delScale * VV.img.CROP_PORT * scaleSlider.pinch.sensitivity;
        //$('#desc').val(newScale.toString() + ' ' + oScale.toString() + ' ' + delScale.toString());
        $('#desc').val(delScale);
        var currentX = scaleSlider.currentPosit;
        var transientX = currentX + delScale;
        var minX = 0;
        var maxX = scaleSlider.travel;

        if(transientX <= minX) {
           var currentX = minX;
        } else if(transientX >= maxX) {
           var currentX = maxX;
        } else {
           var currentX = transientX;
        }
        scaleSlider.currentPosit = currentX;
        var scale = scaleSlider.percent() + 1;
        var margin = currentX + scaleSlider.stopLimits;
        $('#scaleSliderBut').css('margin-left', margin + 'px');
        VV.img.scaler(scale, $('#img_preview'), $('#cropPortBg img'));
        oScale = newScale;  
    });
}

/*******************
* Loader *
*******************/
var loader = {
    state: false,
    run: function ($cont) {
        this.state = true;
        console.log('loader: ' + loader.state);
        var loading = '<div id="loader" style="position:absolute">Loading...</div>';
        $cont.prepend(loading);
        $('#loader').velocity("fadeIn", {
            duration: 500, loop: true });
    },
    kill: function(callback) {
        var self = this;
        $('#loader').velocity("stop").velocity("fadeOut", {
            duration: 300,
            complete: function(el) {
                $(el).remove();
                self.state = false;
                console.log('loader: ' + loader.state);
                if(typeof callback === 'function') return callback();
            }
        });
    }
}

/*******************
* Image processing *
*******************/

/* Functional schema
    
    $("#img_field").change()
        !--> reader.readAsDataURL()
                !--> reader.onload()
                        !--> VV.img.STOCK_IMG.onload()
                                !--> ends.
*/

var $img_field = $('img_field');
var el_img_field = document.getElementById('img_field');

VV.img.STOCK_IMG.onload = function() {
    var self = this;
    console.log('img onload');

    //480x480
    if(this.height < 480 || this.width < 480 ) {
        loader.kill();
        return aF.protoAlert({
                text:'Please select an image with at least 480px by 480px resolution', 
                title:'Resolution too small'
        });
    }

    VV.img.STOCK_IMG_MP = this.height*this.width/1000000;
    if(VV.img.STOCK_IMG_MP > VV.img.RESIZE_MP_LIMIT) {
        loader.kill();
        return aF.protoAlert({
                text:'Please resize your image before uploading.', 
                title:'Resolution too high'
        });
    }

    //ok clear to proceed...

    //store the heights for use later.
    VV.img.STOCK_IMG_W = this.width;
    VV.img.STOCK_IMG_H = this.height;
    

    //TRANSITIONS
    $("#browseCont").velocity("transition.slideLeftOut", 300);
    $("#cropPort").css('cursor', 'move');

    //check if image MP within prescribed limits
    var clientCanHandle = (VV.img.CSRender >= VV.img.STOCK_IMG_MP);
    var imageIsBelowHardLimit = (VV.img.STOCK_IMG_MP <= VV.img.RESIZE_MP_LIMIT);

    if(clientCanHandle && imageIsBelowHardLimit) {
        //get EXIF first
        VV.img.getEXIF(el_img_field.files[0], function(toRotate) {
            var canvas = VV.img.canvasrise(self);
            //set resizer
            
            var scaleTo = VV.img.CROP_SIZE*VV.img.SCALE_LIMIT;
            //resize and rotate
            VV.img.canvasResize(canvas, scaleTo, toRotate, function(canvas) {
                VV.img.dispTmp('canvas', canvas);  
            });  

        });
    } else {
        //upload the image that client can't handle
        var attrs = {
            action: 'raw',
            imgData: el_img_field.files[0],
            processData: false
        }
        return VV.img.upload(attrs, function(data) {
            VV.img.dispTmp('imgData', data.pathToImg);
        }); //VV.img.upload;
    }    
} //img onload

var reader = new FileReader();
reader.onload = function(e) {
    VV.img.STOCK_IMG.src = e.target.result;
}

//File Input onchange
$("#img_field").change(function(){
    var self = this;
    console.log("New file");

    //STEP 1: Rejection or accept */
    if(!this.files && !this.files[0]) { return false; }

    //console.log(this.files[0].size);
    if( this.files[0].size > 3145728 ) {
        return aF.protoAlert({
                text:'Your image file is too large. Please resize your image to below 3mb.', 
                title:'Max filesize exceeded.'
            });
    }

    //objectURL method not supported by Firefox
    //var objectURL = URL.createObjectURL(this.files[0]);

    if($('#img_preview').length > 0) {
        $('#cropPortBg img').velocity("fadeOut", { 
            duration: 300,
            complete: function(el) { 
                $(el).remove(); 
            }
        });
        $('#img_preview').velocity("fadeOut", {
            duration: 300,
            complete: function(el) {
                $(el).remove();
                $('.img_previews').remove();
                loader.run($('#cropPort'));
                reader.readAsDataURL(self.files[0]);
                //VV.img.STOCK_IMG.src = objectURL;
            }
        });
    } else {
        loader.run($('#cropPort'));
        reader.readAsDataURL(this.files[0]);
        
        //VV.img.STOCK_IMG.src = objectURL;
    }
    //reset all globals
    VV.img.resetGlobal();
    scaleSlider.reset($('#scaleSliderBut'));
});

/******************
* Post processing *
******************/


$("#doneScaling").click(function(){
    //unbind dragShifting
    var $cP = $('#cropPort');
    dragShifting.kill($cP);
    loader.run($cP);
    $cP.css('cursor', 'default');

    //slideout scale container
    $('#scaleCont').velocity('transition.slideLeftOut', {duration: 300});

    //This option is only available to client-side render.
    //1. crop and resize VV.img.TEMP_IMG.
    //2. re-apply filters.

    if(VV.img.CSRender !== false) {
        var tempCanvas = document.createElement('canvas');
        var tempCanvasCtx = tempCanvas.getContext('2d');
        tempCanvas.height = VV.img.TEMP_IMG_H;
        tempCanvas.width = VV.img.TEMP_IMG_W;
        tempCanvasCtx.drawImage(VV.img.TEMP_IMG, 0, 0);

        //m tells you how much bigger the image used for processing is.
        //this is used to multiply the drag shifted offsets IMG_X and IMG_Y
        if(tempCanvas.height > tempCanvas.width) {
            var m = VV.img.TEMP_IMG_W / (VV.img.CROP_PORT*VV.img.SCALE);
        } else {
            var m = VV.img.TEMP_IMG_H / (VV.img.CROP_PORT*VV.img.SCALE);
        }

        VV.img.canvasCrop('canvas', tempCanvas, m, VV.img.SCALE, function(cropped) {
            VV.img.canvasResize(cropped, VV.img.CROP_SIZE, false, function(canvas) {
                //in future, apply filters here.
                canvas.style['height'] = VV.img.CROP_PORT + 'px';
                canvas.style['width'] = VV.img.CROP_PORT + 'px';
                canvas.id = 'img_preview2';
                canvas.className = 'img_previews';
                
                //transitions
                loader.kill();
                $('#cropPortBg img').velocity({opacity:0}, 300, function() {
                    $('#img_preview').hide();
                    $('#cropPort').append(canvas);
                    $('#postCont').velocity('transition.slideRightIn', 300);
                }); 

            });
        });
    } else {
        //transitions
        loader.kill();
        $('#cropPortBg img').velocity({opacity:0}, 300, function() {
            $('#postCont').velocity('transition.slideRightIn', 300);
        }); 
    }
}); // #processImage click


$("#postIt").click(function(){

    //loader.run($('#cropPort'));
    $("#postCont").velocity("transition.slideLeftOut", 300);
    $("#progressBarCont").velocity("transition.slideRightIn", 300);

    if(VV.img.CSRender !== false) {
        //var submittedCanvas = document.getElementById('img_preview');
        //var tempCanvas = VV.img.cloneCanvas(submittedCanvas);
        // VV.img.canvasResize(tempCanvas, VV.img.CROP_SIZE*VV.img.SCALE, false, function(canvas) {

        //     VV.img.canvasCrop('canvas', canvas, function(data) {
        //         var blobBin = atob( data.split(',')[1] );
        //         var array = [];
        //         for(var i = 0; i < blobBin.length; i++) {
        //             array.push(blobBin.charCodeAt(i));
        //         }
        //         var file = new Blob([new Uint8Array(array)], {type: 'image/jpeg'});

        //         var attrs = {
        //             action: 'store',
        //             imgData: file,
        //             processData: false,
        //             desc: $('#desc').val()
        //         }

        //         VV.img.upload(attrs, function(data) {
        //             //redirect to post
        //             window.location.href = '/';
        //             console.log(data.postId);
        //         });
        //     });
        // });

        var el_finalCanvas = document.getElementById('img_preview2');

        var data = el_finalCanvas.toDataURL('image/jpeg', VV.img.QUALITY);
        var blobBin = atob( data.split(',')[1] );
        var array = [];
        for(var i = 0; i < blobBin.length; i++) {
            array.push(blobBin.charCodeAt(i));
        }
        var file = new Blob([new Uint8Array(array)], {type: 'image/jpeg'});

        var attrs = {
            action: 'store',
            imgData: file,
            processData: false,
            desc: $('#desc').val()
        }

        VV.img.upload(attrs, function(data) {
            //redirect to post
            loader.kill();
            window.location.href = '/p/' + data.postId;
            console.log(data.postId);
            
        });

    } else {

        var processData = {
            crop: {
                x: VV.img.IMG_X,
                y: VV.img.IMG_Y,
                scale: VV.img.SCALE,
                cp: VV.img.CROP_PORT
            }
        }
        console.log(processData);

        var attrs = {
            action: 'process',
            imgData: VV.img.TEMP_IMG.src,
            processData: processData,
            desc: $('#desc').val()
        }

        VV.img.upload(attrs, function(data) {
            loader.kill();
            window.location.href = '/p/' + data.postId;
            console.log(data.postId);
            
        });
    }    
}); //submit onclick
</script>

{>blockFooterScripts/}
